---
title: 630. 课程表 III
author: Ackerman
date: 2021-12-15 01:06:40
categories:
- [Learning, LeetCode]
tags:
- Python
- Golang
- 堆（优先队列）
- 贪心
---

### [630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/)

这里有 `n` 门不同的在线课程，按从 `1` 到 `n` 编号。给你一个数组 `courses` ，其中 `courses[i] = [durationi, lastDayi]` 表示第 `i` 门课将会 **持续** 上 `durationi` 天课，并且必须在不晚于 `lastDayi` 的时候完成。

你的学期从第 `1` 天开始。且不能同时修读两门及两门以上的课程。

返回你最多可以修读的课程数目。

<!-- more -->

**示例 1：**

```
输入：courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出：3
解释：
这里一共有 4 门课程，但是你最多可以修 3 门：
首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。
第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。
第三，修第 2 门课，耗时 200 天，在第 1300 天完成。
第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。
```

**示例 2：**

```
输入：courses = [[1,2]]
输出：1
```

**示例 3：**

```
输入：courses = [[3,2],[4,3]]
输出：0
```

 

**提示:**

- `1 <= courses.length <= 104`
- `1 <= durationi, lastDayi <= 104`



### Solutions

#### 思路

1. 按 lastDay 排序课程，lastDay 越近的，越要优先考虑（deadline 是第一生产力）
2. 若准备修读的课程中，无法再塞下当前课程，可以替换掉准备修读的课程中耗时最大的课程。这样可以保证修读的课程数量不会少，耗时是局部最优的（贪心算法）

{% tabs tab, 1%}

<!--tab Python-->

```python
class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        q = []
        total = 0
        for time, deadline in sorted(courses, key=lambda x:x[1]):
            if total + time > deadline and q and -q[0] > time:
                total += heapq.heappop(q)

            if total + time <= deadline:
                heapq.heappush(q, -time)
                total += time
        
        return len(q)
```

<!-- endtab -->

<!--tab Golang-->

```go
import (
    "container/heap"
    "sort"
)

func scheduleCourse(courses [][]int) int {
    sort.Slice(courses, func(i, j int) bool {
        return courses[i][1] < courses[j][1]
    })
    pq, t := &Heap{}, 0
    for _, course := range courses {
        d, l := course[0], course[1]
        if t+d > l && pq.Len() > 0 && pq.IntSlice[0] > d {
            t -= heap.Pop(pq).(int)
        }
        if t+d <= l {
            t += d
            heap.Push(pq, d)
        }
    }
    return pq.Len()
}

type Heap struct {
    sort.IntSlice
}

func (h *Heap) Less(i, j int) bool {
    return h.IntSlice[i] > h.IntSlice[j]
}

func (h *Heap) Swap(i, j int) {
    h.IntSlice[i], h.IntSlice[j] = h.IntSlice[j], h.IntSlice[i]
}

func (h *Heap) Push(x interface{}) {
    h.IntSlice = append(h.IntSlice, x.(int))
}

func (h *Heap) Pop() interface{} {
    a := h.IntSlice
    x := a[len(a)-1]
    h.IntSlice = a[:len(a)-1]
    return x
}
```

<!-- endtab -->

{% endtabs %}

